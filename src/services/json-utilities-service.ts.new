import * as vscode from 'vscode';
import { ErrorHandler } from '../core/error-handler';
import { JsonContextDetector } from '../utils/json-context-detector';
import { JsonError, JsonWarning, JsonValidationResult } from '../types/json-types';
import { JsonValidator } from './json-validator';

export interface JsonFormattingOptions {
    indent: number;
    sortKeys: boolean;
    removeComments: boolean;
    removeTrailingCommas: boolean;
    insertFinalNewline: boolean;
    maxLineLength: number;
    preserveArrayFormatting: boolean;
}

export class JsonUtilitiesService {
    private static instance: JsonUtilitiesService;
    private errorHandler: ErrorHandler;
    private outputChannel: vscode.OutputChannel;
    private defaultOptions: JsonFormattingOptions;

    private constructor(errorHandler: ErrorHandler) {
        this.errorHandler = errorHandler;
        this.outputChannel = vscode.window.createOutputChannel('DoraCodeBird JSON Utilities');
        this.defaultOptions = {
            indent: 2,
            sortKeys: false,
            removeComments: false,
            removeTrailingCommas: false,
            insertFinalNewline: true,
            maxLineLength: 120,
            preserveArrayFormatting: true
        };
    }

    public static getInstance(errorHandler?: ErrorHandler): JsonUtilitiesService {
        if (!JsonUtilitiesService.instance) {
            if (!errorHandler) {
                throw new Error('ErrorHandler required for first initialization');
            }
            JsonUtilitiesService.instance = new JsonUtilitiesService(errorHandler);
        }
        return JsonUtilitiesService.instance;
    }

    public isJsonContext(document?: vscode.TextDocument, position?: vscode.Position): boolean {
        return JsonContextDetector.isJsonContext(document, position);
    }

    /**
     * Format JSON content
     */
    public async formatJson(content: string, options?: Partial<JsonFormattingOptions>): Promise<string> {
        try {
            // First check if it looks like a Python dict
            if (this.isPythonDictLike(content)) {
                // If it looks like Python, try to convert it first
                const fixedJson = await this.fixPythonDictToJson(content);
                const parsedJson = JSON.parse(fixedJson);
                return JSON.stringify(parsedJson, null, this.defaultOptions.indent);
            }
            // Try to parse as regular JSON
            const parsedJson = JSON.parse(content);
            return JSON.stringify(parsedJson, null, this.defaultOptions.indent);
        } catch (error) {
            // If regular JSON parse fails, try to fix Python dict syntax as fallback
            const fixedJson = await this.fixPythonDictToJson(content);
            const parsedJson = JSON.parse(fixedJson);
            return JSON.stringify(parsedJson, null, this.defaultOptions.indent);
        }
    }

    /**
     * Convert Python dict to JSON
     */
    private async fixPythonDictToJson(content: string): Promise<string> {
        try {
            // First clean up the content
            const cleanContent = this.cleanupPythonDict(content);
            
            // Then do a full parse and transform
            const processed = this.processPythonDict(cleanContent);
            
            // Validate the result
            JSON.parse(processed); // Will throw if invalid
            return processed;
            
        } catch (error) {
            // Add context to the error message
            if (error instanceof Error) {
                if (error.message.includes('position')) {
                    const match = error.message.match(/position (\d+)/);
                    if (match) {
                        const pos = parseInt(match[1]);
                        const lines = content.split('\n');
                        let currentPos = 0;
                        for (let i = 0; i < lines.length; i++) {
                            if (currentPos + lines[i].length >= pos) {
                                throw new Error(
                                    `Failed to convert Python dictionary: ${error.message} (line ${i + 1} column ${pos - currentPos + 1})`
                                );
                            }
                            currentPos += lines[i].length + 1;
                        }
                    }
                }
                throw new Error(`Failed to convert Python dictionary: ${error.message}`);
            }
            throw error;
        }
    }

    /**
     * Initial cleanup of Python dict syntax
     */
    private cleanupPythonDict(content: string): string {
        // Remove comments
        let result = content
            .replace(/#[^\n]*/g, '')              // Single-line comments
            .replace(/'''[\s\S]*?'''/g, '')       // Triple-single-quoted strings
            .replace(/"""[\s\S]*?"""/g, '');      // Triple-double-quoted strings

        // Remove trailing commas
        result = result.replace(/,(\s*[}\]])/g, '$1');
        result = result.replace(/,(\s*[\r\n]+\s*[}\]])/g, '$1');

        // Normalize indentation and whitespace while preserving structure
        result = result
            .split('\n')
            .map(line => line.trimRight())  // Only trim right to preserve indentation
            .filter(line => line.length > 0)
            .join('\n');

        // Convert Python special values
        result = result
            .replace(/\bTrue\b/g, 'true')
            .replace(/\bFalse\b/g, 'false')
            .replace(/\bNone\b/g, 'null');

        return result;
    }

    /**
     * Process Python dict content into valid JSON
     */
    private processPythonDict(content: string): string {
        let result = '';
        let inString = false;
        let stringChar = '';
        let escaped = false;
        let bracketStack: string[] = [];
        
        for (let i = 0; i < content.length; i++) {
            const char = content[i];
            
            if (escaped) {
                result += inString ? this.handleEscapedChar(char, stringChar) : char;
                escaped = false;
                continue;
            }

            if (char === '\\') {
                escaped = true;
                result += char;
                continue;
            }

            if (char === "'" || char === '"') {
                if (!inString) {
                    inString = true;
                    stringChar = char;
                    result += '"';  // Always use double quotes for JSON
                } else if (char === stringChar) {
                    inString = false;
                    result += '"';  // Close with double quotes
                } else {
                    result += char; // Keep quotes in string content as is
                }
                continue;
            }

            if (!inString) {
                // Track brackets for better structure validation
                if (char === '{' || char === '[') {
                    bracketStack.push(char);
                } else if (char === '}' || char === ']') {
                    if (bracketStack.length === 0) {
                        throw new Error('Unmatched closing bracket');
                    }
                    const lastBracket = bracketStack.pop();
                    if ((char === '}' && lastBracket !== '{') || 
                        (char === ']' && lastBracket !== '[')) {
                        throw new Error('Mismatched brackets');
                    }
                }
            }
            
            result += char;
        }

        if (inString) {
            throw new Error('Unterminated string');
        }

        if (bracketStack.length > 0) {
            throw new Error('Unclosed brackets');
        }

        return result;
    }

    /**
     * Handle escaped characters in string conversion
     */
    private handleEscapedChar(char: string, stringChar: string): string {
        if (char === stringChar) {
            return char;
        }
        if (char === 'n') return '\\n';
        if (char === 't') return '\\t';
        if (char === 'r') return '\\r';
        return char;
    }

    /**
     * Check if content looks like a Python dictionary
     */
    private isPythonDictLike(content: string): boolean {
        const trimmed = content.trim();
        return trimmed.startsWith('{') && 
               (trimmed.includes("'") || 
                trimmed.includes('True') || 
                trimmed.includes('False') || 
                trimmed.includes('None'));
    }

    /**
     * Cleanup and dispose of resources
     */
    public dispose(): void {
        this.outputChannel.dispose();
    }
}
